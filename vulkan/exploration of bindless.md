# Exploration onf bindless degisn, A GPU driven design

There is no doubt that in modern days, we need our renderers to be bindless. The good-old-days state machine APIs bring tones of troubles in optimization and most importantly: they make our code messy.

I started learning OpenGL during the last year of my high school, I was attracted immediately by how powerful and beautiful graphics programming can be. I just simplily enjoy working with low level graphics system and yes I do like games.

However, as time goes by, I ran into a dead end: I can not build simplily an abstraction layer/renderer or something similar on OpenGL that is both scalable and modular. The codes got extremely messy and chaotics. I realized there is barely an elegant way to build such renderer. Everything was just couple together and somehow the performance will never be good.......

Then I try what so call "Mordern OpenGL" and DX11, things still looks bad. They help me decouple my code and make them a little bit modular by trading a huge codebase. Most importantly, there was not a measureable performance leap in my code. And precisely at that time, I know I need to try something new. Which is Vulkan.

So what happens exactly? In those legacy APIs, everything was binded in to slots. Vetex buffer, Index buffer, etc. The change of primitives have to be done by the changes of tones of binding. Mordern OpenGL does bring indirect drawing which helps me reduce some of the API calls, but still that wasn't enought. I need everything possible to be bindless and fully GPU driven. Luckliy with Vulkan, we have buffer device reference, aka pointers.

## GPU side Design
Let's move on to the first version of the design:
There are 2 parts of the design, a huge buffer holding all data, and a huge descriptor holding all textures.
```c++
struct PrimInfo
{
    uint64_t position_ = EMPTY_L; // vec3[]
    uint64_t normal_ = EMPTY_L;   // vec3[]
    uint64_t tangent_ = EMPTY_L;  // vec4[]
    uint64_t texcoord_ = EMPTY_L; // vec2[]
    uint64_t joints_ = EMPTY_L;   // uvec4[]
    uint64_t weights_ = EMPTY_L;  // vec4[]

    uint64_t idx_ = EMPTY_L;      // uint32_t[]
    uint64_t mesh_ = EMPTY_L;     // MeshInfo*
    uint64_t material_ = EMPTY_L; // MaterialInfo*
    uint64_t morph_ = EMPTY_L;    // MorphInfo*
}
```
This is the basic primitive infomation structure stored inside a huge data buffer. They will be indexed by `gl_DrawID` generated by the GPU in vertex shader. All of them are just pointers pointing to the same data buffer.
```c++
struct MaterialInfo
{
    glm::vec4 color_factor_ = {1, 1, 1, 1};
    glm::vec4 emissive_factor_ = {0, 0, 0, 1};       // [3] = emissive strength
    glm::vec4 sheen_color_factor_ = {0, 0, 0, 0};    // [3] = sheen roughtnessfactor
    glm::vec4 specular_color_factor_ = {1, 1, 1, 1}; // [3] = specular factor
    float alpha_cutoff_ = 0; // -1 means blend, 0 means opaque, otherwise meansmask
    float metalic_factor_ = 1.0f;
    float roughtness_factor_ = 1.0f;
    uint32_t color_ = EMPTY;
    uint32_t metalic_roughtness_ = EMPTY;
    uint32_t normal_ = EMPTY;
    uint32_t emissive_ = EMPTY;
    uint32_t occlusion_ = EMPTY;
    float anisotropy_rotation_ = 0;
    float anisotropy_strength_ = 0;
    uint32_t anisotropy_ = EMPTY;
    uint32_t specular_ = EMPTY;
    uint32_t spec_color_ = EMPTY;
    uint32_t sheen_color_ = EMPTY;
    uint32_t sheen_roughtness_ = EMPTY;
};
```
This the material information structure that will be accessd in fragment shader. It contains some material data and indices of a huge texture descriptor array.

There are only 1 binding in this design, whcih is to bind the huge texture array. It can be replaced by descriptor indexing but it will make it overly complicated.

## CPU side design
It is not hard to tell that there are no such thing call vertex buffer anymore. All data are just pointers now! That bring a significant improve about how the data should be structed: There is no need to group all vertex together; they can be anywhere in side the data buffer. That means I can allocate a large size buffer and change the primitives I would like to render on the fly. That brings the problem of fragmentation, so unfortunally I decide not to implement such feature.

more to come.....

